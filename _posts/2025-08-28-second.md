---
title: "MediaPipeë¡œ ë§Œë“œëŠ” ì›¹ìº  ì† ì¶”ì  ê²Œì„ ì›¹ì•±"
date: 2025-08-28 06:40:00 +0900
categories: [AI]
tags: [mediapipe, ë°”ì´ë¸Œì½”ë”©, gamedev]
---

## MediaPipeë¡œ ë§Œë“œëŠ” ì›¹ìº  ì† ì¶”ì  ê²Œì„

ì•ˆë…•í•˜ì„¸ìš”! ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ì›¹ìº ì„ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ìì˜ ì† ì›€ì§ì„ì„ ì¸ì‹í•˜ê³ , ì´ë¥¼ í†µí•´ ì¦ê¸¸ ìˆ˜ ìˆëŠ” ê°„ë‹¨í•œ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê²Œì„ì„ ë§Œë“œëŠ” ë°©ë²•ì„ ì†Œê°œí•©ë‹ˆë‹¤. Googleì˜ **MediaPipe** ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•˜ì—¬ ë³„ë„ì˜ ì¥ë¹„ ì—†ì´ë„ ì‹¤ì‹œê°„ ì† ì¶”ì  ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê³ , ìˆœìˆ˜ JavaScriptì™€ Tailwind CSSë¡œ ì¸í„°ë™í‹°ë¸Œí•œ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•˜ëŠ” ì „ì²´ ê³¼ì •ì„ ë‹¤ë£¹ë‹ˆë‹¤.

### ğŸ® í”„ë¡œì íŠ¸ ê°œìš”

ì´ ê²Œì„ì˜ ëª©í‘œëŠ” ê°„ë‹¨í•©ë‹ˆë‹¤. í™”ë©´ì— ë‚˜íƒ€ë‚˜ëŠ” ì—¬ëŸ¬ ìƒ‰ìƒì˜ ì‚¬ê°í˜• ì¤‘ **ê°™ì€ ìƒ‰ì„ ê°€ì§„ ì‚¬ê°í˜•ë¼ë¦¬ ì†ìœ¼ë¡œ ì§‘ì–´ ê²¹ì¹˜ê²Œ ë§Œë“¤ì–´ ì—†ì• ëŠ” ê²ƒ**ì…ë‹ˆë‹¤. 

<ë§ˆì´ë„ˆë¦¬í‹° ë¦¬í¬íŠ¸ ì›¹ê²Œì„! ğŸ–ï¸> 
- ì›¹ìº  ì•ì—ì„œ ê²€ì§€ì™€ ì¤‘ì§€ë¡œ ì§‘ì€ ì±„, ê°™ì€ ìƒ‰ ë¸”ë¡ì„ í•©ì¹˜ë©´ ë! 
- ì´ 3ë¼ìš´ë“œë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.
- ì°½ì²´ í™œë™ì´ë‚˜ ì‰¬ëŠ” ì‹œê°„, ëˆ„ê°€ ë” ë¹¨ë¦¬ 3ë¼ìš´ë“œë¥¼ í†µê³¼í•˜ëŠ”ì§€ ê°„ë‹¨í•˜ê²Œ ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ ê¸°ë¡ ëŒ€ê²° ì–´ë–¨ê¹Œìš”?
- ìƒëŒ€ì ìœ¼ë¡œ í° í™”ë©´ì¸ PC í™˜ê²½(ì›¹ìº )ì—ì„œ êµ¬ë™(ëª¨ë°”ì¼ X)  
- [í”„ë¡œì íŠ¸ í˜ì´ì§€ ë°”ë¡œê°€ê¸°](https://minority-report.netlify.app/)

  
### ğŸ› ï¸ ì£¼ìš” ê¸°ìˆ  ìŠ¤íƒ

* **HTML5:** ì›¹ í˜ì´ì§€ì˜ ê¸°ë³¸ êµ¬ì¡°ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤. `<video>` íƒœê·¸ë¡œ ì›¹ìº  ì˜ìƒì„ ë°›ê³ , `<canvas>` íƒœê·¸ì— ê²Œì„ í™”ë©´ì„ ê·¸ë¦½ë‹ˆë‹¤.
* **Tailwind CSS:** ìœ í‹¸ë¦¬í‹° ìš°ì„  CSS í”„ë ˆì„ì›Œí¬ë¡œ, ë¹ ë¥´ê³  íš¨ìœ¨ì ì¸ UI ìŠ¤íƒ€ì¼ë§ì„ ìœ„í•´ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
* **JavaScript (ES Modules):** ê²Œì„ì˜ ëª¨ë“  ë¡œì§ê³¼ ë™ì  ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
* **MediaPipe Hands:** ì›¹ìº  ì˜ìƒì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ì†ì˜ ëœë“œë§ˆí¬(ê´€ì ˆ ìœ„ì¹˜)ë¥¼ ê°ì§€í•˜ëŠ” í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.

### ğŸ’» ì „ì²´ ì½”ë“œ (All in one)

ì•„ë˜ ì½”ë“œë¥¼ `index.html` íŒŒì¼ë¡œ ì €ì¥í•˜ê³  ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ë©´ ë°”ë¡œ ê²Œì„ì„ ì‹¤í–‰í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì¹´ë©”ë¼ ì ‘ê·¼ ê¶Œí•œ í—ˆìš© í•„ìš”)

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Drag & Drop Game</title>
    <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
    <link rel="preconnect" href="[https://fonts.googleapis.com](https://fonts.googleapis.com)">
    <link rel="preconnect" href="[https://fonts.gstatic.com](https://fonts.gstatic.com)" crossorigin>
    <link href="[https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap](https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap)" rel="stylesheet">
    <script src="[https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js](https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js)" crossorigin="anonymous"></script>
    <script src="[https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js](https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js)" crossorigin="anonymous"></script>
    <script src="[https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js](https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js)" crossorigin="anonymous"></script>
    <script src="[https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js](https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js)" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* ë¡œë”© ìŠ¤í”¼ë„ˆ ìŠ¤íƒ€ì¼ */
        .loader {
            border: 8px solid #f3f3f3;
            border-radius: 50%;
            border-top: 8px solid #3498db;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .screen-overlay {
            /* ì˜¤ë²„ë ˆì´ í™”ë©´ ìŠ¤íƒ€ì¼: ë” ì–´ë‘¡ê²Œ í•˜ì—¬ ì§‘ì¤‘ë„ í–¥ìƒ */
            @apply absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 z-20 hidden;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4 overflow-hidden">

    <div class="w-full max-w-4xl mx-auto text-center">
        <h1 class="text-3xl md:text-4xl font-bold mb-2">ì† ì¶”ì  ë“œë˜ê·¸ & ë“œë¡­ ê²Œì„</h1>
        <p class="text-gray-400 mb-4">ê°™ì€ ìƒ‰ ì‚¬ê°í˜•ë¼ë¦¬ ê²¹ì³ì„œ ëª¨ë‘ ì—†ì• ë³´ì„¸ìš”!</p>
        
        <div id="controls" class="my-4">
            <button id="startButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">
                ê²Œì„ ì‹œì‘
            </button>
        </div>

        <div id="container" class="relative w-full aspect-video bg-gray-800 rounded-lg overflow-hidden shadow-2xl hidden">
            <video id="webcam" class="hidden"></video>
            <canvas id="outputCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            
            <div id="loading" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-50 z-30">
                <div class="loader"></div>
                <p class="mt-4 text-lg">ì¹´ë©”ë¼ì™€ ëª¨ë¸ì„ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤...</p>
            </div>
            <div id="roundStartScreen" class="screen-overlay">
                <h2 id="roundText" class="font-bold text-5xl sm:text-7xl">Round 1</h2>
            </div>
            <div id="roundClearScreen" class="screen-overlay">
                <h2 id="roundClearText" class="font-bold text-green-400 mb-4 text-4xl sm:text-6xl">Round 1 Clear!</h2>
                <p class="text-xl sm:text-3xl">ê¸°ë¡: <span id="roundClearTime" class="font-bold">0.00ì´ˆ</span></p>
            </div>
            
            <div id="gameOverFrame" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-600 flex flex-col items-center justify-center z-20 hidden w-11/12 max-w-md">
                <h2 class="font-bold text-yellow-400 mb-4 text-4xl sm:text-5xl text-center">ê²Œì„ í´ë¦¬ì–´!</h2>
                <p class="text-xl sm:text-2xl mb-2">ìµœì¢… í•©ì‚° ê¸°ë¡:</p>
                <p id="finalTime" class="font-bold mb-8 text-3xl sm:text-5xl">0.00ì´ˆ</p>
                <button id="restartButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 w-full">
                    ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // DOM ìš”ì†Œ
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startButton = document.getElementById('startButton');
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const gameOverFrame = document.getElementById('gameOverFrame');
        const finalTimeElement = document.getElementById('finalTime');
        const restartButton = document.getElementById('restartButton');
        const roundStartScreen = document.getElementById('roundStartScreen');
        const roundText = document.getElementById('roundText');
        const roundClearScreen = document.getElementById('roundClearScreen');
        const roundClearText = document.getElementById('roundClearText');
        const roundClearTime = document.getElementById('roundClearTime');

        // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
        let gameActive = false;
        let roundActive = false;
        let roundStartTime = 0;
        let currentRound = 1;
        const totalRounds = 3;
        let roundTimes = [];

        // ì‚¬ê°í˜• í´ë˜ìŠ¤
        class DragRect {
            constructor(posCenter, size, color) {
                this.posCenter = posCenter; this.size = size; this.color = color;
                this.originalColor = color; this.isDragging = false;
            }
            update(cursor) {
                const [cx, cy] = this.posCenter; const [w, h] = this.size;
                const [cursorX, cursorY] = cursor;
                if (cursorX > cx - w / 2 && cursorX < cx + w / 2 && cursorY > cy - h / 2 && cursorY < cy + h / 2) {
                    this.posCenter = cursor; this.isDragging = true; return true;
                }
                return false;
            }
            reset() { this.isDragging = false; }
            draw(ctx) {
                const [cx, cy] = this.posCenter; const [w, h] = this.size;
                const x = cx - w / 2; const y = cy - h / 2;
                ctx.fillStyle = this.isDragging ? 'rgba(0, 255, 0, 0.7)' : this.color;
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4; const cornerLength = Math.min(20, w/4);
                ctx.beginPath();
                ctx.moveTo(x, y + cornerLength); ctx.lineTo(x, y); ctx.lineTo(x + cornerLength, y);
                ctx.moveTo(x + w - cornerLength, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + cornerLength);
                ctx.moveTo(x + w, y + h - cornerLength); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - cornerLength, y + h);
                ctx.moveTo(x + cornerLength, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - cornerLength);
                ctx.stroke();
            }
        }

        let rectList = [];
        let hands;

        // ì¶©ëŒ ê³„ì‚° í•¨ìˆ˜
        function checkCollision(rect1, rect2) {
            if (rect1.color !== rect2.color) return false;
            const [cx1, cy1] = rect1.posCenter; const [w1, h1] = rect1.size;
            const x1_left = cx1 - w1 / 2, x1_right = cx1 + w1 / 2;
            const y1_top = cy1 - h1 / 2, y1_bottom = cy1 + h1 / 2;
            const [cx2, cy2] = rect2.posCenter; const [w2, h2] = rect2.size;
            const x2_left = cx2 - w2 / 2, x2_right = cx2 + w2 / 2;
            const y2_top = cy2 - h2 / 2, y2_bottom = cy2 + h2 / 2;
            const overlapX = Math.max(0, Math.min(x1_right, x2_right) - Math.max(x1_left, x2_left));
            const overlapY = Math.max(0, Math.min(y1_bottom, y2_bottom) - Math.max(y1_top, y2_top));
            const overlapArea = overlapX * overlapY;
            const rect1Area = w1 * h1;
            return (overlapArea / rect1Area) >= 0.4;
        }

        // ë©”ì¸ ë Œë”ë§ ë£¨í”„
        function onResults(results) {
            if (!canvasElement.width || !canvasElement.height) return;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.translate(canvasElement.width, 0); canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (roundActive) {
                let isGrabbing = false; let cursorPosition = null; let draggedRect = null;
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const ix = lm[8].x * canvasElement.width, iy = lm[8].y * canvasElement.height; // ê²€ì§€ ë
                    const mx = lm[12].x * canvasElement.width, my = lm[12].y * canvasElement.height; // ì¤‘ì§€ ë
                    const distance = Math.sqrt(Math.pow(ix - mx, 2) + Math.pow(iy - my, 2));
                    if (distance < 65) { // ë‘ ì†ê°€ë½ ì‚¬ì´ì˜ ê±°ë¦¬ê°€ íŠ¹ì • ê°’ë³´ë‹¤ ê°€ê¹Œìš°ë©´ 'ì¡ê¸°'ë¡œ ì¸ì‹
                        isGrabbing = true; cursorPosition = [canvasElement.width - ix, iy];
                    }
                }
                if (isGrabbing) {
                    for (const rect of rectList) {
                        if (rect.update(cursorPosition)) { draggedRect = rect; break; }
                    }
                } else { rectList.forEach(rect => rect.reset()); }
                if (draggedRect) {
                    const toRemove = new Set();
                    for (const rect of rectList) {
                        if (rect !== draggedRect && checkCollision(draggedRect, rect)) {
                            toRemove.add(draggedRect); toRemove.add(rect);
                        }
                    }
                    if (toRemove.size > 0) { rectList = rectList.filter(rect => !toRemove.has(rect)); }
                }
            }
            rectList.forEach(rect => rect.draw(canvasCtx));

            if (roundActive) {
                const elapsedTime = ((Date.now() - roundStartTime) / 1000).toFixed(2);
                canvasCtx.save();
                canvasCtx.font = "bold 32px Inter";
                canvasCtx.fillStyle = "yellow";
                canvasCtx.textAlign = "right";
                canvasCtx.shadowColor = 'black';
                canvasCtx.shadowBlur = 7;
                canvasCtx.fillText(`Round ${currentRound} | ${elapsedTime}s`, canvasElement.width - 20, 50);
                canvasCtx.restore();

                if (rectList.length === 0) {
                    roundActive = false;
                    gameActive = false; 
                    const finalRoundTime = parseFloat(elapsedTime);
                    roundTimes.push(finalRoundTime);
                    showRoundClearScreen(finalRoundTime);
                }
            }
        }
        
        function showRoundClearScreen(time) {
            roundClearText.textContent = `Round ${currentRound} Clear!`;
            roundClearTime.textContent = `${time.toFixed(2)}ì´ˆ`;
            roundClearScreen.style.display = 'flex';

            setTimeout(() => {
                roundClearScreen.style.display = 'none';
                currentRound++;
                if (currentRound > totalRounds) {
                    endGame();
                } else {
                    startNewRound();
                }
            }, 2000);
        }

        function initializeRects(round) {
            rectList = [];
            const rows = 4; const cols = 2;
            const canvasArea = canvasElement.width * canvasElement.height;
            // ë¼ìš´ë“œê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì‚¬ê°í˜•ì´ ì‘ì•„ì ¸ ë‚œì´ë„ ìƒìŠ¹
            const coverage = round === 1 ? 0.6 : (round === 2 ? 0.3 : 0.1);
            const singleRectArea = (canvasArea * coverage) / (rows * cols);
            const rectSize = Math.sqrt(singleRectArea);
            const colors = ['rgba(255, 0, 255, 0.7)', 'rgba(0, 255, 255, 0.7)', 'rgba(255, 255, 0, 0.7)', 'rgba(255, 0, 0, 0.7)'];
            const xMargin = (canvasElement.width - (cols * rectSize)) / (cols + 1);
            const yMargin = (canvasElement.height - (rows * rectSize)) / (rows + 1);
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = xMargin * (c + 1) + rectSize * c + rectSize / 2;
                    const y = yMargin * (r + 1) + rectSize * r + rectSize / 2;
                    rectList.push(new DragRect([x, y], [rectSize, rectSize], colors[r]));
                }
            }
        }
        
        function startNewRound() {
            roundText.textContent = `Round ${currentRound}`;
            roundStartScreen.style.display = 'flex';
            setTimeout(() => {
                roundStartScreen.style.display = 'none';
                initializeRects(currentRound);
                roundActive = true;
                gameActive = true; 
                roundStartTime = Date.now();
            }, 2000);
        }
        
        function endGame() {
            gameActive = false; 
            const totalTime = roundTimes.reduce((acc, time) => acc + time, 0);
            finalTimeElement.textContent = `${totalTime.toFixed(2)}ì´ˆ`;
            gameOverFrame.style.display = 'flex';
        }

        function startGame() {
            currentRound = 1;
            roundTimes = [];
            rectList = []; 
            
            gameOverFrame.style.display = 'none';
            roundClearScreen.style.display = 'none';
            roundStartScreen.style.display = 'none';
            
            container.classList.remove('hidden');
            startButton.classList.add('hidden');
            loading.style.display = 'flex';
            
            if (!hands) {
                hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
                hands.onResults(onResults);
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (videoElement.readyState >= 3) {
                            if (loading.style.display !== 'none') {
                                loading.style.display = 'none';
                                canvasElement.width = videoElement.videoWidth;
                                canvasElement.height = videoElement.videoHeight;
                                startNewRound();
                            }
                            if(gameActive) await hands.send({ image: videoElement });
                        }
                    }, width: 1280, height: 720
                });
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } } })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.onloadedmetadata = () => camera.start();
                    }).catch(err => {
                        console.error("ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:", err); alert("ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
                    });
            } else {
                loading.style.display = 'none'; 
                startNewRound();
            }
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
    </script>
</body>
</html>
```

<table align="center">
  <tr>
    <td>
      <img src="/assets/hand.jpg" alt="í‘œ" width="500">
    </td>
  </tr>
  <tr>
    <td>
      <img src="/assets/hand1.jpg" alt="í‘œ" width="500">
    </td>
  </tr>
</table>
